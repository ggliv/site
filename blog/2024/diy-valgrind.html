<!DOCTYPE html><html lang="en"> <head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Make your own Valgrind with LD_PRELOAD | Gabe Livengood</title><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#282ED8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#2987D9"><meta property="og:type" content="website"><meta property="og:title" content="Make your own Valgrind with LD_PRELOAD"><meta property="og:image" content="//github.com/ggliv.png"><meta property="og:description" content="Because creating bad versions of good things is fun"><meta name="description" content="Because creating bad versions of good things is fun"><link rel="alternate" type="application/rss+xml" title="Blog RSS" href="/blog/feed.xml"><link rel="stylesheet" href="/_astro/_slug_.BV00Yjsh.css"></head> <body class="min-h-screen flex flex-col gap-8 bg-gray-900 text-gray-100 light:bg-gray-100 light:text-gray-900"> <header> <div class="h-[1rem] w-full bg-mega-blue light:bg-mega-blue-light"></div> <h1 class="py-[0.5rem] pl-[0.5rem] pr-[1rem] rounded-br-xl w-fit bg-mega-blue light:bg-mega-blue-light font-fredoka font-bold text-3xl text-white brightness-125"> <a href="/blog/">Gabe's Blog</a> </h1> </header> <main class="px-[1rem] md:w-[var(--breakpoint-md)] md:mx-auto"> <h1 class="mb-[1rem] font-bold text-5xl">Make your own Valgrind with LD_PRELOAD</h1>  <div class="text-lg"> <p>
Filed under  <span class="whitespace-nowrap">
[  <a class="link" href="/blog/tags/c">#c</a>, <a class="link" href="/blog/tags/cpp">#cpp</a>, <a class="link" href="/blog/tags/linux">#linux</a> 
]
</span> </p> <p class="mb-[2rem]">25 September 2024</p> </div> <div class="prose prose-invert light:prose-slate max-w-none leading-snug prose-headings:font-bold prose-h1:text-4xl prose-a:text-blue-300 light:prose-a:text-blue-700 prose-a:underline">  <p>One of the big dangers of languages that have manual memory management (most notably C and C++) is the potential for memory leaks. Consider the following super useful, totally-not-contrived C program:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">#include</span><span style="color:#9ECBFF"> &lt;stdlib.h&gt;</span></span>
<span class="line"><span style="color:#F97583">#include</span><span style="color:#9ECBFF"> &lt;stdio.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">int</span><span style="color:#F97583"> *</span><span style="color:#B392F0">get_int</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">void</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#B392F0"> malloc</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">sizeof</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">int</span><span style="color:#E1E4E8">));</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">int</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">void</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  int</span><span style="color:#F97583"> *</span><span style="color:#E1E4E8">i </span><span style="color:#F97583">=</span><span style="color:#B392F0"> get_int</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">  *</span><span style="color:#E1E4E8">i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 9</span><span style="color:#F97583"> +</span><span style="color:#79B8FF"> 10</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#B392F0">  printf</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;</span><span style="color:#79B8FF">%d\n</span><span style="color:#9ECBFF">&quot;</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">i);</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> EXIT_SUCCESS;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Running this program does what it says on the tin—allocates an <code>int</code>-sized chunk of memory on the heap, stores something there, prints it, and then dies. But beware! That <code>int</code> that we allocate is never freed, meaning that up until the moment the process ends,<sup><a href="#user-content-fn-os-mm" id="user-content-fnref-os-mm" data-footnote-ref aria-describedby="footnote-label">1</a></sup> you have an <code>int</code> with nothing to do floating around on the heap and hogging up space.</p>
<p>This is a memory leak. It’s not a big deal here, but you can imagine that in a bigger program with lots more allocations and a longer run time (say, your web browser), the space used up by leaked memory can be significant.</p>
<p>This is bad. Thankfully, the systems programming luminaries of yesteryear recognized this problem and put together some tooling for detecting leaks. We’ll talk about one of these tools and try to make our own simple version of it for fun.</p>
<h1 id="valgrind">Valgrind</h1>
<p><a href="https://valgrind.org/">Valgrind</a> is a general-purpose memory debugging tool that can, among other things, detect and report leaks in programs. Let’s see what it has to say about our example program from earlier:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="console"><code><span class="line"><span style="color:#E1E4E8">$ cc ex.c -o ex.out</span></span>
<span class="line"><span style="color:#E1E4E8">$ valgrind ./ex.out</span></span>
<span class="line"><span style="color:#79B8FF">==264361== Memcheck, a memory error detector</span></span>
<span class="line"><span style="color:#79B8FF">==264361== Copyright (C) 2002-2024, and GNU GPL&#39;d, by Julian Seward et al.</span></span>
<span class="line"><span style="color:#79B8FF">==264361== Using Valgrind-3.23.0 and LibVEX; rerun with -h for copyright info</span></span>
<span class="line"><span style="color:#79B8FF">==264361== Command: ./ex.out</span></span>
<span class="line"><span style="color:#79B8FF">==264361==</span></span>
<span class="line"><span style="color:#79B8FF">19</span></span>
<span class="line"><span style="color:#79B8FF">==264361==</span></span>
<span class="line"><span style="color:#79B8FF">==264361== HEAP SUMMARY:</span></span>
<span class="line"><span style="color:#79B8FF">==264361==     in use at exit: 4 bytes in 1 blocks</span></span>
<span class="line"><span style="color:#79B8FF">==264361==   total heap usage: 2 allocs, 1 frees, 1,028 bytes allocated</span></span>
<span class="line"><span style="color:#79B8FF">==264361==</span></span>
<span class="line"><span style="color:#79B8FF">==264361== LEAK SUMMARY:</span></span>
<span class="line"><span style="color:#79B8FF">==264361==    definitely lost: 4 bytes in 1 blocks</span></span>
<span class="line"><span style="color:#79B8FF">==264361==    indirectly lost: 0 bytes in 0 blocks</span></span>
<span class="line"><span style="color:#79B8FF">==264361==      possibly lost: 0 bytes in 0 blocks</span></span>
<span class="line"><span style="color:#79B8FF">==264361==    still reachable: 0 bytes in 0 blocks</span></span>
<span class="line"><span style="color:#79B8FF">==264361==         suppressed: 0 bytes in 0 blocks</span></span>
<span class="line"><span style="color:#79B8FF">==264361== Rerun with --leak-check=full to see details of leaked memory</span></span>
<span class="line"><span style="color:#79B8FF">==264361==</span></span>
<span class="line"><span style="color:#79B8FF">==264361== For lists of detected and suppressed errors, rerun with: -s</span></span>
<span class="line"><span style="color:#79B8FF">==264361== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</span></span></code></pre>
<p>Valgrind is telling us that we allocated twice and freed only once, leaking 4 bytes (the size of an <code>int</code> on my machine). The other allocation that we didn’t explicitly make comes from somewhere inside of the guts of <code>libc</code>, probably stemming from our <code>printf</code> call.</p>
<p>This is super convenient. Instead of carefully poring over each allocation we write to make sure they’re all properly freed, we can now just run our program through Valgrind and identify whether there is or isn’t a problem. In the event that there are problems, you can even run Valgrind with some extra options to identify where the leak occured (though this is out of scope for what we’re making in this post).</p>
<h1 id="linking-and-ld_preload">Linking and <code>LD_PRELOAD</code></h1>
<p>When you write a program that uses an external library, your computer needs to be able to locate and execute the library’s code when you try to call into it. Doing this is the job of a program called the linker. Broadly speaking, linking can be done in two ways: statically and dynamically.</p>
<p>Static linking is pretty much a “copy and paste” operation from the library’s code into your program’s code. The instructions from the library get baked directly into your instructions. This is good for portability (since the binary contains everything it needs to run) and can even improve performance in some cases (since linking is done ahead of time and everything is located one place).<sup><a href="#user-content-fn-lto" id="user-content-fnref-lto" data-footnote-ref aria-describedby="footnote-label">2</a></sup></p>
<p>With dynamic linking, your program comes bundled with a list of library functions that it requires and leaves it up to the operating system to find them at run time. Just before your program starts, the operating system’s dynamic linker will search all over your computer for shared objects that provide the required functions and make them accessible to your program. This is good for modularity (you can just update the shared library file to update all consuming programs) and helps save disk space (since you only need one copy of a library for all the programs that use it).</p>
<p>Dynamic linking gives us a fun new tool to play with. Imagine that we wanted to change the behavior of a program that’s already been compiled. If that program relies on dynamic linking to load some library function, we can step in and convince the operating system to look somewhere other than the proper place for that code. On Linux,<sup><a href="#user-content-fn-preload-other-unix" id="user-content-fnref-preload-other-unix" data-footnote-ref aria-describedby="footnote-label">3</a></sup> this can be done with the <code>LD_PRELOAD</code> environment variable. From <code>ld.so(8)</code>:</p>
<blockquote>
<p>LD_PRELOAD</p>
<p>A list of additional, user-specified, ELF shared objects to be loaded before all others. This feature can be used to selectively override functions in other shared objects.</p>
</blockquote>
<p>Because they’re so commonly used, systems-level libraries are dynamically linked into programs in the vast majority of cases. Luckily enough, this includes <code>libc</code>, the C standard library, which is where we get <code>malloc</code> and <code>free</code>. If we preloaded in our own shim around those two functions and did some bookkeeping, we could report on program exit whether or not there are any leaks!</p>
<h1 id="writing-a-shim">Writing a shim</h1>
<p>Let’s do just that. We have two functions<sup><a href="#user-content-fn-other-alloc" id="user-content-fnref-other-alloc" data-footnote-ref aria-describedby="footnote-label">4</a></sup> that we want to shim: <code>malloc</code> and <code>free</code>. We’ll keep track of everything that we allocate in a linked list, remove items from that linked list when we free them, and then print out how many bytes were left over on exit.</p>
<p>First, let’s start with a simple proof of concept shim around <code>malloc</code>:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">#include</span><span style="color:#9ECBFF"> &lt;stdlib.h&gt;</span></span>
<span class="line"><span style="color:#F97583">#include</span><span style="color:#9ECBFF"> &lt;stdio.h&gt;</span></span>
<span class="line"><span style="color:#F97583">#include</span><span style="color:#9ECBFF"> &lt;dlfcn.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">void</span><span style="color:#F97583"> *</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">*</span><span style="color:#E1E4E8">orig_malloc)(</span><span style="color:#F97583">size_t</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">void</span><span style="color:#B392F0"> shims_atexit</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">void</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#B392F0">  printf</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Shimmed!</span><span style="color:#79B8FF">\n</span><span style="color:#9ECBFF">&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">void</span><span style="color:#F97583"> *</span><span style="color:#B392F0">malloc</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">size_t</span><span style="color:#FFAB70"> size</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (orig_malloc </span><span style="color:#F97583">==</span><span style="color:#79B8FF"> NULL</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#B392F0">      atexit</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&amp;</span><span style="color:#E1E4E8">shims_atexit);</span></span>
<span class="line"><span style="color:#E1E4E8">      orig_malloc </span><span style="color:#F97583">=</span><span style="color:#B392F0"> dlsym</span><span style="color:#E1E4E8">(RTLD_NEXT, </span><span style="color:#9ECBFF">&quot;malloc&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#B392F0"> orig_malloc</span><span style="color:#E1E4E8">(size);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>This code declares a new version of <code>malloc</code> that, when called for the first time, registers a custom function <code>shims_atexit</code> to run when the program terminates. In this exit function we simply print out the message “Shimmed!” to console. We also save the real <code>malloc</code> to the function pointer <code>orig_malloc</code> by telling the dynamic linker to find and load the next <code>malloc</code> symbol it found while searching the system.</p>
<p>To compile the above program, we run:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="console"><code><span class="line"><span style="color:#E1E4E8">$ cc shims.c -shared -fPIC -o shims.so</span></span></code></pre>
<p>This says to compile the program <code>shims.c</code> as a shared library, enables the flag for <strong>P</strong>osition <strong>I</strong>ndependent <strong>C</strong>ode, and saves the output to <code>shims.so</code>.</p>
<p>Let’s see how this shim works with the example program we wrote at the beginning of the post:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="console"><code><span class="line"><span style="color:#E1E4E8">$ LD_PRELOAD</span><span style="color:#F97583">=</span><span style="color:#9ECBFF">./shims.so</span><span style="color:#B392F0"> ./ex.out</span></span>
<span class="line"><span style="color:#79B8FF">19</span></span>
<span class="line"><span style="color:#79B8FF">Shimmmed!</span></span></code></pre>
<p>Nice. The dynamic loader is grabbing our version of <code>malloc</code> and calling it when the example program tries to allocate an <code>int</code>. Let’s fill things out with the rest of our logic.</p>
<p>We’ll start with the boring bits—one struct and a few globals. The struct is for a node in a doubly-linked list, which we’ll use for all of the bookkeeping for shimmed allocations. We’ll manage this linked list with the POSIX <code>insque</code> and <code>deque</code> functions declared in <code>search.h</code>. The two function pointers are for us to store and later call the real versions of the functions we’re shimming. Lastly, the <code>set_up</code> variable is a simple flag to indicate when some setup code we’ll later write has already been called.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">#include</span><span style="color:#9ECBFF"> &lt;search.h&gt;</span></span>
<span class="line"><span style="color:#F97583">#include</span><span style="color:#9ECBFF"> &lt;stddef.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> AllocNode {</span></span>
<span class="line"><span style="color:#F97583">  struct</span><span style="color:#E1E4E8"> AllocNode </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">next;</span></span>
<span class="line"><span style="color:#F97583">  struct</span><span style="color:#E1E4E8"> AllocNode </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">prev;</span></span>
<span class="line"><span style="color:#F97583">  void</span><span style="color:#F97583"> *</span><span style="color:#E1E4E8">ptr;</span></span>
<span class="line"><span style="color:#F97583">  size_t</span><span style="color:#E1E4E8"> size;</span></span>
<span class="line"><span style="color:#E1E4E8">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> AllocNode </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">head;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">void</span><span style="color:#F97583"> *</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">*</span><span style="color:#E1E4E8">orig_malloc)(</span><span style="color:#F97583">size_t</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">void</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">*</span><span style="color:#E1E4E8">orig_free)(</span><span style="color:#F97583">void</span><span style="color:#F97583"> *</span><span style="color:#E1E4E8">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">int</span><span style="color:#E1E4E8"> set_up;</span></span></code></pre>
<p>Next we’ll jump ahead and define our exit handler. When the program terminates, anything remaining in the linked list is a leak. We’ll traverse the list and print out information on each node we see.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">#include</span><span style="color:#9ECBFF"> &lt;stddef.h&gt;</span></span>
<span class="line"><span style="color:#F97583">#include</span><span style="color:#9ECBFF"> &lt;stdio.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">void</span><span style="color:#B392F0"> shims_atexit</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">void</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  while</span><span style="color:#E1E4E8"> (head </span><span style="color:#F97583">!=</span><span style="color:#79B8FF"> NULL</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#B392F0">    printf</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;</span><span style="color:#79B8FF">%lu</span><span style="color:#9ECBFF"> bytes from pointer </span><span style="color:#79B8FF">%p</span><span style="color:#9ECBFF"> were not freed!</span><span style="color:#79B8FF">\n</span><span style="color:#9ECBFF">&quot;</span><span style="color:#E1E4E8">, head-&gt;size,</span></span>
<span class="line"><span style="color:#E1E4E8">            head-&gt;ptr);</span></span>
<span class="line"><span style="color:#F97583">    struct</span><span style="color:#E1E4E8"> AllocNode </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">next </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> head-&gt;next;</span></span>
<span class="line"><span style="color:#B392F0">    orig_free</span><span style="color:#E1E4E8">(head);</span></span>
<span class="line"><span style="color:#E1E4E8">    head </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> next;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>After that, we’ll make a function responsible for grabbing a pointer to the real allocation functions and registering our exit handler. We’ll call this once when our shims are first used to make sure things are in a sane state.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">#include</span><span style="color:#9ECBFF"> &lt;dlfcn.h&gt;</span></span>
<span class="line"><span style="color:#F97583">#include</span><span style="color:#9ECBFF"> &lt;stdlib.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">void</span><span style="color:#B392F0"> shims_setup</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">void</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">set_up) {</span></span>
<span class="line"><span style="color:#E1E4E8">    orig_malloc </span><span style="color:#F97583">=</span><span style="color:#B392F0"> dlsym</span><span style="color:#E1E4E8">(RTLD_NEXT, </span><span style="color:#9ECBFF">&quot;malloc&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    orig_free </span><span style="color:#F97583">=</span><span style="color:#B392F0"> dlsym</span><span style="color:#E1E4E8">(RTLD_NEXT, </span><span style="color:#9ECBFF">&quot;free&quot;</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#B392F0">    atexit</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">&amp;</span><span style="color:#E1E4E8">shims_atexit);</span></span>
<span class="line"><span style="color:#E1E4E8">    set_up </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Now we have everything we need to write the first actual shim (around <code>malloc</code>):</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">void</span><span style="color:#F97583"> *</span><span style="color:#B392F0">malloc</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">size_t</span><span style="color:#FFAB70"> size</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">set_up)</span></span>
<span class="line"><span style="color:#B392F0">    shims_setup</span><span style="color:#E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  // make our new node</span></span>
<span class="line"><span style="color:#F97583">  struct</span><span style="color:#E1E4E8"> AllocNode </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">new </span><span style="color:#F97583">=</span><span style="color:#B392F0"> orig_malloc</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">sizeof</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">struct</span><span style="color:#E1E4E8"> AllocNode));</span></span>
<span class="line"><span style="color:#E1E4E8">  new-&gt;size </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> size;</span></span>
<span class="line"><span style="color:#E1E4E8">  new-&gt;ptr </span><span style="color:#F97583">=</span><span style="color:#B392F0"> orig_malloc</span><span style="color:#E1E4E8">(size);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  // insert it into the linked list</span></span>
<span class="line"><span style="color:#B392F0">  insque</span><span style="color:#E1E4E8">(new, head);</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (head </span><span style="color:#F97583">==</span><span style="color:#79B8FF"> NULL</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">    head </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> new;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  // pass the new allocation to the caller</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> new-&gt;ptr;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Next, around <code>free</code>:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">void</span><span style="color:#B392F0"> free</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">void</span><span style="color:#F97583"> *</span><span style="color:#FFAB70">ptr</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (ptr </span><span style="color:#F97583">==</span><span style="color:#79B8FF"> NULL</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">  } </span><span style="color:#F97583">else</span><span style="color:#F97583"> if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">set_up) {</span></span>
<span class="line"><span style="color:#B392F0">    shims_setup</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  // find the node we&#39;re freeing</span></span>
<span class="line"><span style="color:#F97583">  struct</span><span style="color:#E1E4E8"> AllocNode </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">search </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> head;</span></span>
<span class="line"><span style="color:#F97583">  while</span><span style="color:#E1E4E8"> (search-&gt;ptr </span><span style="color:#F97583">!=</span><span style="color:#E1E4E8"> ptr) {</span></span>
<span class="line"><span style="color:#E1E4E8">    search </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> search-&gt;next;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (search </span><span style="color:#F97583">==</span><span style="color:#E1E4E8"> head) {</span></span>
<span class="line"><span style="color:#E1E4E8">    head </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> head-&gt;next;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  // free the pointer and take it out of our linked list</span></span>
<span class="line"><span style="color:#B392F0">  orig_free</span><span style="color:#E1E4E8">(search-&gt;ptr);</span></span>
<span class="line"><span style="color:#B392F0">  remque</span><span style="color:#E1E4E8">(search);</span></span>
<span class="line"><span style="color:#B392F0">  orig_free</span><span style="color:#E1E4E8">(search);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>And that’s it! Here’s <a href="https://nopaste.boris.sh/?l=c#XQAAAQAzBQAAAAAAAAARmknGRw8TogB3Oxl4CFPTJk56zZ6jfFaTq0qTJ0ngf3DXdtYjM4H/sqUeZYisyS5aBP5bpQTf+gEu/KfkUbLUx54rxX6hPxF8cm2eDPDDDJ0FW0q9w+KR7VQ3t1jme8+42PeZDcRqnkshNG2OFFYkkDki168abNEms9VQxxgapSgPAgLwpRmzxZ79k6yj22WthImdsBdv1xfPmNPpdlBAn7hIU5MT36N/c0JJoaUqDCANO5ZuTz9eqvypCNnmJ0mqKvhOIhhFwO7oFCyBqCVo6sYPyAPHxkliv0IRmesoT8ItgKP1TjY+QFJ9YFaGXjNFGUp3tCFvbkH+IOOr3f331kcoH/f2gdz9C8rzCZ2mxXttERtsskB1HK+nd4OQiPFBFtwGM1XbTFCCoYwCkeLbLtde0bK5ZoQAxK0CWVL5tENj4u3X2puaPwY1q8quQvN6S1bqa6qShjRemx4keZ803kbYMfVN4289JcL3AKTCARO8KI0fMy2t/VfiyNPLQi93EdzJSBDmksHziktrF4rshsKyC0x24S29i1/lMBt+d3Hz8CWNA/AXXP6JrQm+7uGGcdSYEydTqv4HVFxKFjHzahByykPpq8xjJ3EpFvEGPSo+YqKtGIzjqb+qLQby3eSf+OaTC4mk2a0m+VRKzhY4Ieq5GUBOS2Ci2z7/Q1wTDbn8Urbg">everything put together into one file</a>.</p>
<h1 id="results">Results</h1>
<p>Let’s test our new leak checker with that first example program.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="console"><code><span class="line"><span style="color:#E1E4E8">$ cc ex.c -o ex.out</span></span>
<span class="line"><span style="color:#E1E4E8">$ cc shims.c -shared -fPIC -o shims.so</span></span>
<span class="line"><span style="color:#E1E4E8">$ LD_PRELOAD</span><span style="color:#F97583">=</span><span style="color:#9ECBFF">./shims.so</span><span style="color:#B392F0"> ./ex.out</span></span>
<span class="line"><span style="color:#79B8FF">19</span></span>
<span class="line"><span style="color:#79B8FF">4 bytes from pointer 0x64a17f2442d0 were not freed!</span></span>
<span class="line"><span style="color:#79B8FF">1024 bytes from pointer 0x64a17f244320 were not freed!</span></span></code></pre>
<p>Awesome. Those extra 1024 bytes of leakage seem to be from the internals of <code>malloc</code> this time. While not ideal, fixing this issue would (as far as I know) require significantly more complex code than what we wrote here.</p>
<p>If we modify our example program to properly free its allocation like this:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="diff"><code><span class="line"><span style="color:#79B8FF">diff --git a/ex.c b/ex_fix.c</span></span>
<span class="line"><span style="color:#E1E4E8">index 4335186..7e52d09 100644</span></span>
<span class="line"><span style="color:#FDAEB7"><span style="user-select:none">-</span>-- a/ex.c</span></span>
<span class="line"><span style="color:#85E89D"><span style="user-select:none">+</span>++ b/ex.c</span></span>
<span class="line"><span style="color:#B392F0;font-weight:bold">@@ -11,5 +11,6 @@</span><span style="color:#E1E4E8"> int main(void)</span></span>
<span class="line"><span style="color:#E1E4E8">   int *i = get_int();</span></span>
<span class="line"><span style="color:#E1E4E8">   *i = 9 + 10;</span></span>
<span class="line"><span style="color:#E1E4E8">   printf(&quot;%d\n&quot;, *i);</span></span>
<span class="line"><span style="color:#85E89D"><span style="user-select:none">+</span>  free(i);</span></span>
<span class="line"><span style="color:#E1E4E8">   return EXIT_SUCCESS;</span></span>
<span class="line"><span style="color:#E1E4E8"> }</span></span></code></pre>
<p>And then recompile and run with our shims again:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="console"><code><span class="line"><span style="color:#E1E4E8">$ cc ex.c -o ex.out</span></span>
<span class="line"><span style="color:#E1E4E8">$ LD_PRELOAD</span><span style="color:#F97583">=</span><span style="color:#9ECBFF">./shims.so</span><span style="color:#B392F0"> ./ex.out</span></span>
<span class="line"><span style="color:#79B8FF">19</span></span></code></pre>
<p>We don’t get any leak messages! Success!</p>
<section data-footnotes class="footnotes"><h2 class="sr-only" id="footnote-label">Footnotes</h2>
<ol>
<li id="user-content-fn-os-mm">
<p>Though all reasonable systems do, nothing in the C or C++ standard actually requires the operating system to clean up unfreed memory at process termination. So in some cases you could actually continue leaking memory even after the process ends. <a href="#user-content-fnref-os-mm" data-footnote-backref aria-label="Back to reference 1" class="data-footnote-backref">↩</a></p>
</li>
<li id="user-content-fn-lto">
<p>There’s also Link Time Optimization (LTO), which adds more metadata (usually compiler IR) to a library so that the linker can perform optimizations once the whole program is known. This isn’t <em>really</em> your typical static linking though, it’s kind of its own thing. <a href="#user-content-fnref-lto" data-footnote-backref aria-label="Back to reference 2" class="data-footnote-backref">↩</a></p>
</li>
<li id="user-content-fn-preload-other-unix">
<p>From some brief searching it looks like <code>LD_PRELOAD</code> is also available on other flavors of Unix, including Solaris, SunOS, HP-UX, and the BSDs. On macOS, you’d use <code>DYLD_INSERT_LIBRARIES</code>. <a href="#user-content-fnref-preload-other-unix" data-footnote-backref aria-label="Back to reference 3" class="data-footnote-backref">↩</a></p>
</li>
<li id="user-content-fn-other-alloc">
<p>For a more complete solution you’d really want to include shims for <code>calloc</code>, <code>realloc</code>, and <code>reallocarray</code>. Adding those other functions should follow pretty clearly from what’s done here, and is left as an exercise for the reader. <a href="#user-content-fnref-other-alloc" data-footnote-backref aria-label="Back to reference 4" class="data-footnote-backref">↩</a></p>
</li>
</ol>
</section>  </div>  </main> <footer class="mt-auto"> <div class="text-center w-full light:bg-gray-200 text-gray-500 bg-gray-800 p-[0.5rem]"> <div> <a class="md:inline-block" href="/">Home</a>
&middot;
<a class="md:inline-block" href="/blog/feed.xml">RSS</a>
&middot;
<a class="md:inline-block" href="#">Top</a> </div> <div> <p class="group md:inline-block"> <span class="inline-block motion-safe:group-hover:[transform:rotateY(180deg)] transition-transform">&copy;</span> 2023-2025 Gabe Livengood
</p> <span class="hidden md:inline-block">&middot;</span> <p class="md:inline-block">
Blog content is <a href="//creativecommons.org/licenses/by-sa/4.0/">CC-BY-SA-4.0</a>. Code examples are <a href="//choosealicense.com/licenses/mit/">MIT</a>.
</p> </div> </div> </footer> </body></html>